## 用C语言实现内存写入
### 目标：画图形（数据写入VRAM 320*200 a0000 ~ affff 64kb）
### 实现：
1. 使用c语言，c语言没有直接写入内存地址的语句 
2. 汇编实现，c调用汇编
3. mov指令，哪些寄存器可以使用（EAX、ECX、EDX），如何传参（ESP + 4n） 
```asm
_write_mem8:	; void write_mem8(int addr, int data);
    MOV		ECX,[ESP+4]		;
    MOV		AL,[ESP+8]		;
    MOV		[ECX],AL
    RET
```
4. 重复执行write_mem8（for循环 c语言实现/自己汇编实现/和编译器对比）
* c语言实现
```c
int i;
for (i = 0xa0000; i <= 0xaffff; i++) {
    write_mem8(i, 15);
}
```
* 自己汇编实现
```asm
    MOV ESI, 0xa0000    BE 000A0000 
    MOV AL, 0xf         B0 0F
l:	
    CMP ESI, 0xaffff    81 FE 000AFFFF
    JA s                77 05
    MOV [ESI], AL       88 06
    INC ESI             46
    JMP l               EB F3
s:  RET                 C3	
```
* 编译器编译
```asm
    mov EBX, 655360
L6:
    PUSH 15
    PUSH EBX
    INC EBX
    CALL _write_mem8
    CMP EBX, 720895
    POP EAX
    POP EDX
    JB L6
```
### 其他
原码，反码和补码（同一个数的三种表示方法）
* **原码**：数值前面增加了一位符号位（即最高位为符号位），正数该位为0，负数该位为1，其余位表示数值的大小。例如，我们用8位二进制表示一个数，+11的原码为`00001011`，-11的原码就是`10001011`
* **反码**：正数的反码与其原码相同；负数的反码是对正数逐位取反，符号位保持为1，反码通常是用来由原码求补码或者由补码求原码的过渡码
* **补码**：正整数的补码是其二进制表示，与原码相同，负整数的补码，将其原码除符号位外的所有位取反（0变1，1变0，符号位为1不变）后加1。例如，求-5的补码，-5对应带符号位负数5（`10000101`）→除符号位外所有位取反（`11111010`）→加 `00000001`为 (`11111011`)。在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理
